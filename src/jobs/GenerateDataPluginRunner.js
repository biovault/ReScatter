import PluginFactory from '../config/plugins/PluginFactory';
const nrrdjs = require('nrrd-js');
const ndarray = require('ndarray');
const uuid4 = require('uuid/v4');
/**
 * GenerateDataPluginRunner connects a data generating plugin to the
 * the ReScatter data model for plots and choropleths. If a new data set is created
 * by a plugin it will be added to the list of data sets just as if it had been
 * defined in the website configuration.
 */
export default class GenerateDataPluginRunner {
    /**
     * Create a
     * @param activePlugin
     */
    constructor(name) {
        this.plugin = PluginFactory.createDataJobType(name);
    }

    /**
     * get the job(s) monitor
     * @returns {*} a jobs monitor for the job plugin. This recieves signals from the running job
     */
    get monitor() {
        return this.plugin.jobMonitor;
    }

    /**
     * Run the data selection through the plugin to generate a newplot layout.
     * The current layout (accessed through the layoutManager) is use as a template
     * for the new layout based on the data subselection. Plot, choropleths and any
     * datamaps have to be created in the new layout
     * @param selection - object containing {id: 'selection id string', dataPoints: 'numerical indices for the selection')
     */
    run(selection) {
        'use strict';
        let recalc = ReScatter.layoutManager.getRecalculation();
        if (recalc === undefined) {
            return; //nothing to do
        }
        let newDataMap = {};
        ReScatter.layoutManager.getDataMaps().forEach(function(val) {
            newDataMap[val.id] = val.filePath;
        });
        let baseDataMap = {};
        ReScatter.layoutManager.getBaseDataMaps().forEach(function(val) {
            baseDataMap[val.id] = val.filePath;
        });

        let selectionId = selection.selectionId;
        let selections = selection.dataPoints;
        let cache = ReScatter.dataModel.dataCache;
        // create a tSNE job for each plot
        // first assemble the data
        let pathAndTypeList = [];

        let analysisNames = Object.getOwnPropertyNames(recalc.dataAnalysis.analyses);
        let dataList = [];
        // Prefetch base data for analyses
        // First collect all the unique data paths
        analysisNames.forEach(val => {
            let ipData = recalc.dataAnalysis.analyses[val].inputData;
            if (!dataList.includes(ipData)) {
                dataList.push(ipData);
                pathAndTypeList.push({path:baseDataMap[ipData], type: 'arraybuffer'});
            }
        });
        this.preprocessPlugin = PluginFactory.createPreprocessType(recalc.dataAnalysis.dataPreprocess.preprocessPlugin);
        let self = this;
        let currentLayoutId = ReScatter.layoutManager.getId();
        let submitJobs = function(){
            let jobId = uuid4();
            // Step 1: preprocess data
            let recalcData = self.preprocessPlugin.getRecalculationData(jobId, cache, recalc, selections, selectionId);
            let cacheDataMap = self.preprocessPlugin.getDataMap();
            // make a job for each recalculation datum
            analysisNames.forEach(analysisName => {
                let data = recalcData[analysisName];
                let config = recalc.dataAnalysis.analyses[analysisName];
                self.plugin.addJob(data, config, analysisName);
            });
            for (let name of Object.getOwnPropertyNames(newDataMap)) {
                newDataMap[name] = cacheDataMap[name];
            }

            let layouts = new ReScatter.data.LayoutCollection();
            let jobCallback = function(results){
                let title = 'Generated by: ' + self.plugin.constructor.getAlgorithmName() + ' from selection: ' + selection.label;
                let description = selection.description;
                let plotMap = {};
                let propMap = {};
                for (let i=0; i<results.length; i++) {
                    // Cache key for results is the jobGroup uuid plus the unique (sub-)plot.id
                    let analysisId = results[i][0];
                    let subPlotId = recalc.dataAnalysis.analyses[analysisId].targetPlotId;
                    let resultKey = jobId + '_data_' + subPlotId;
                    // The plot coordinates as nrrd are unpacked to an ndarray and from there
                    // to a point object to be stored in the cache.
                    let resultObject = results[i][1];
                    let nrrdFile = nrrdjs.parse(resultObject);
                    let resultArray = ndarray(nrrdFile.data, nrrdFile.sizes.slice().reverse());
                    // accept 2d or id result arrays
                    if ((resultArray.shape.length !== 1) &&
                        !(resultArray.shape.length === 2 && resultArray.shape[1] === 2 )) {
                        throw 'Plugin data was neither 1 or 2 dimensional';
                    }
                    let numPoints = resultArray.shape[0] / (2 / resultArray.shape.length);
                    let pointObj = {dim:2 , points: new Array(numPoints)};
                    for (let i=0; i < numPoints; i++) {
                        if (resultArray.shape.length === 1) {
                            pointObj.points[i] = [resultArray.get(2*i), resultArray.get((2*i) + 1)];
                        } else {
                            pointObj.points[i] = [resultArray.get(i, 0), resultArray.get(i, 1)];
                        }
                    }

                    //var resultJsonString = JSON.stringify(resultObject);
                    // Need to record both the properties and expression data for the new plot
                    let props = ReScatter.dataModel.getPlotPropSubSelection(subPlotId, selectionId, selections);
                    let propKey = jobId + '_props_' + subPlotId;
                    cache.insertInCache(pointObj, resultKey, true);
                    cache.insertInCache(props, propKey, true);
                    propMap[subPlotId] = propKey;
                    plotMap[subPlotId] = resultKey;
                }
                layouts.addDerivedLayout(currentLayoutId, title, description, plotMap, propMap, newDataMap, selectionId, selections);

            };
            let failCallback = function(err) {
                window.alert('Job failed with error: ' + JSON.stringify(err));
            };
            //Step 2: perform the analyses using the preprocessed data
            self.plugin.start(jobCallback, failCallback);
        };
        cache.loadFiles(pathAndTypeList, submitJobs);
    }
}
