/**
 * Created by baldur on 7/24/15.
 */
//import PIXI from 'pixi.js';
import SelectionSubscriber from '../common/SelectionSubscriber';
import LookupEnum from '../../utils/LookupEnum';
import DataMapper from '../../data/DataMapper';
import PlotPropReader from '../../data/PlotPropReader';
import { SnapshotProtocolForCanvas } from '../../protocols/SnapShotProtocols';
import PlotProtocol from '../../protocols/PlotProtocol';
import SelectionProtocol from '../../protocols/SelectionProtocol';
import ControlProtocol from '../../protocols/ControlProtocol';

const kdTree = require('kd-tree-javascript');

// CustomEvents generated by this class
// rendererLoadProgress - contains -  detail: {progressString:string}
// rendererLoadComplete - contains -  detail: {renderer:this,  rendererId:this.elementId}
// webpack require.context to get a list of files
// see requireAll @ https://webpack.github.io/docs/context.html
//let cursors = require.context('../../cursors', true, /^\.\/.*\.png$/);
// require all the files
//cursors.keys().map(cursors);

//<Class definition for the PixijsPlotController>
export default class PixijsPlotController extends SelectionSubscriber {
    constructor(elementId, plotInfo, selectionConfigs) {
        'use strict';
        super(3);
        this.elementId = elementId;
        this.id = plotInfo.id;
        this.selectionOutId = plotInfo.selections.selectionOut;
        this.dynamicSelectionId = plotInfo.selections.dynamicSelectionOut;
        if (selectionConfigs === undefined) {
            this.switchableSelections = ReScatter.config.SwitchableSelections.newFromPlotInfo(plotInfo);
            selectionConfigs = this.switchableSelections.configNames;
        } else {
            this.switchableSelections = plotInfo.selections.switchableSelections;
        }

        this.currentConfig = selectionConfigs[0];
        this.selectionIn = this.switchableSelections.getSelectionMapping(this.currentConfig);
        this.dynamicSelectionIn = this.switchableSelections.getDynamicSelectionMapping(this.currentConfig);
        this.selectionConfigs = selectionConfigs;

        this.brushType = 'Circle';
        this.mouseOverIndexes = []; // points selected when mouse over is enabled
        this.propertyOverIndexes = []; //points when property seed is selected
        this.processingDynamicSelecton = false;
        $( '#' + elementId ).mouseover(function() {
            $('#' + elementId).css('cursor', 'url(' + ReScatter.cursors('./drawtarget.png') + ') 20 20, auto');

        }).mouseout(function() {
            $( '#' + elementId ).css('cursor', 'default');
        });
        this.frameDelay = 20;
        this.plotElement = $('#' + this.elementId)[0];
        // Actual render size (computed size of container - rather than parent clientWidth)
        this.plotWindowSize = this.plotElement.clientWidth;//this.getParentWidth();
        this.originalSize = this.plotWindowSize;
        this.renderer = PIXI.autoDetectRenderer(this.plotWindowSize, this.plotWindowSize, {autoResize: true, forceFXAA: true, preserveDrawingBuffer:true});
        this.interactionElement = this.renderer.plugins.interaction.interactionDOMElement;

        this.plotElement.appendChild(this.renderer.view); //view is a canvas element where the WebGL result is displayed

        window.addEventListener('resize', this.onResize.bind(this));
        let self = this;

        // Note the z-order of the containers is from back to front
        // i.e. the first containers are drawn first
        // Projection size for scaling (1000)
        this.plotSize = this.plotWindowSize;
        // Base of the render tree
        this.plotRoot = new PIXI.Container();
        this.plotRoot.interactive = true;

        // Container used for the scatter plot
        this.basePlotContainer = new PIXI.Container();
        this.basePlotContainer.interactive = true;
        this.basePlotContainer.filters = undefined;
        this.plotRoot.addChild(this.basePlotContainer);
        this.contextMenuLinked = false;
        this.zoomed = false;

        this.resizeZoom = 1;
        this.maxZoomLevel = 16;
        // zoom levels
        this.zoomLevels = Array.apply(null, {length:self.maxZoomLevel + 1}).map(function(val, indx){
            return Math.pow(2,indx/4);
        });
        this.currentZoomLevel = 0;
        this.zoomFactor = this.zoomLevels[this.currentZoomLevel];

        this.selections = [];
        let selectionDefaults = plotInfo.selections.selectionDefaults || {};
        this.numNeighbours = Object.prototype.hasOwnProperty.call(selectionDefaults, 'numNeighbours') ?  selectionDefaults.numNeighbours : 49;
        this.selectOver = Object.prototype.hasOwnProperty.call(selectionDefaults, 'selectOver') ?  selectionDefaults.selectOver : PixijsPlotController.SelectionEnum.MOUSEOVER;
        this.mouseOverExcludeSeed = Object.prototype.hasOwnProperty.call(selectionDefaults, 'mouseOverExcludeSeed') ? selectionDefaults.mouseOverExcludeSeed : false;

        this.mouseOverSeedIndex = -1;

        //Container used for selected point sprites
        this.selectionsRoot = new PIXI.Container();
        this.selectionsRoot.interactive = false;
        this.plotRoot.addChild(this.selectionsRoot);

        //Container used for displaying transient selections
        this.dynamicRoot = new PIXI.Container();
        this.dynamicRoot.interactive = false;
        this.dynamicRoot.visible = false;
        this.plotRoot.addChild(this.dynamicRoot);
        // Optimization alert!
        // plotRoot.visible = false is used to prevent the
        // InteractionManager from responding on non focussed canvas
        // The InteractionManager slows down the whole system otherwise
        // due to the large number of interactive sprites per plot
        // plotRoot visibility is set to true when the plot gets the focus
        // and back to false when the mouse exits
        this.plotRoot.visible = false;
        // View objects for the selections
        this.selectionViews = {};

        // Container used for rendering ontology popups
        this.popupContainer = new PIXI.Container();
        this.popupContainer.interactive = false;
        this.plotRoot.addChild(this.popupContainer);

        // Container used for brush objects
        this.plotRoot.brushViewTree = new PIXI.Container();
        this.plotRoot.brushViewTree.interactive = false;
        // For ease of reference in the events make activeBrushView and
        // tree children of plotRoot.brushViewTree. plotRoot is the 'this' pointer
        // in the callbacks.
        this.plotRoot.mousedown = this.plotRoot.touchstart = this.startDrawing;
        this.plotRoot.mouseup = this.plotRoot.touchend = this.endDrawing;
        this.plotRoot.click = this.selectOnClick.bind(this);
        this.renderer.view.oncontextmenu = this.onContextMenu.bind(this); //disable the rightclick menu over the plot

        this.interactionElement.addEventListener('wheel', self.zoomWheel.bind(self), false);
        this.interactionElement.addEventListener('mouseover', self.startAnimationFn.bind(self));
        this.interactionElement.addEventListener('mouseout', self.stopAnimationFn.bind(self));
        this.interactionElement.addEventListener('touchstart', self.startAnimationFn.bind(self));
        this.interactionElement.addEventListener('touchmove', self.startAnimationFn.bind(self));

        this.interactionElement.addEventListener('touchleave', self.stopAnimationFn.bind(self));
        this.plotRoot.mousemove = this.plotRoot.touchmove = null;
        this.plotRoot.brushMousemove = this.brushMousemove;
        this.plotRoot.activeBrushView = undefined;
        this.plotRoot.activeBrushModel = undefined;
        this.plotRoot.renderer = this;
        this.plotRoot.captureMouse = false;
        // Respond to mouseup outside this  as the user can finish brushing at an odd location
        let sceneRootMouseUp = this.endDrawing.bind(this.plotRoot);
        document.body.addEventListener('mouseup', function(event) {
            if (self.plotRoot.captureMouse) {
                sceneRootMouseUp(event);
            }
        });
        document.body.addEventListener('touchend', function(event) {
            if (self.plotRoot.captureMouse) {
                sceneRootMouseUp(event);
            }
        });
        document.body.addEventListener('touchcancel', function(event) {
            if (self.plotRoot.captureMouse) {
                sceneRootMouseUp(event);
            }
        });
        this.plotRoot.addChild(this.plotRoot.brushViewTree);
        this.annotations = [];
        this.annotationsColor = [];
        this.allPointSprites = [];

        this.dimensions = 2;
        this.then = Date.now();
        this.inRender = false;
        this.stopAnimation = true;


        // Add a hit area... to allow drawing on the whole image
        this.plotRoot.hitArea = new PIXI.Rectangle(0,0, this.plotWindowSize, this.plotWindowSize);
        this.plotAreaRect = new PIXI.Graphics();
        this.plotAreaRect.lineStyle(2, 0x2F2F2F, 1);
        this.plotAreaRect.drawRect(0, 0, this.plotWindowSize, this.plotWindowSize);
        this.plotRoot.addChild(this.plotAreaRect);

    }

    static brushModeEnum = new LookupEnum({
        CIRCLE: 'Circle',
        RECTANGLE: 'Rectangle',
        FREEHAND: 'Freehand'
    });

    startAnimationFn () {
        this.hasFocus = true;
        this.plotRoot.visible = true;
        if (this.stopAnimation) {
            this.stopAnimation = false;
            this.animate();
        }
    }

    stopAnimationFn () {
        this.popupContainer.removeChildren();
        this.render();
        this.hasFocus = false;
        this.stopAnimation = true;
        this.plotRoot.visible = false;
        if (this.dynamicSelectionId && ReScatter.dynamicSelectionModel) {
            ReScatter.dynamicSelectionModel.removeDynamicSelection(this.dynamicSelectionId);
        }

        //console.log("Lost focus " + this.id);
    }

    animate () {
        'use strict';
        // throttle the rAF depending on activity
        this.now = 0;
        let that = this;
        return (function frameLoop(){
            if (that.stopAnimation) {
                return;
            }
            that.animationId = window.requestAnimationFrame(frameLoop);
            //that.inRender = true;
            //that.render();
            that.now = Date.now();
            let delta = that.now - that.then;
            if (delta > that.frameDelay) {
                that.then = that.now - (delta % that.frameDelay);
                if (!that.inRender) {
                    that.inRender = true;
                    let now = Date.now();

                    that.render();

                    // throttle delay to match actual performance
                    // out of focus run slower
                    // Redundant - animation is killed on loss of focus
                    let actualRenderDelay = Date.now() - now ;
                    if (that.hasFocus) {
                        that.frameDelay = (actualRenderDelay > 120) ? 120: actualRenderDelay;
                        that.frameDelay = (actualRenderDelay < 20) ? 20 : that.frameDelay;
                    } else {
                        that.frameDelay = (actualRenderDelay > 800) ? 800 : actualRenderDelay * 10;
                        that.frameDelay = (actualRenderDelay < 120) ? 120 : that.frameDelay;
                    }
                }
            //    //console.log('Frame delay: ' + that.frameDelay + ' Delta: ' + delta);
            }

        }());
    }


    render (cacheBasePlot) {
        'use strict';
        // now show it
        let sceneRootState = this.plotRoot.visible;
        this.plotRoot.visible = true;
        // This seems like a good idea to enhance performance
        // but the scaling of the bitmap fails in Firefox
        // TODO find a fix
        if (cacheBasePlot) {
            this.basePlotContainer.cacheAsBitmap = true;
        }
        if (this.renderer.gl) {
            this.renderer.render(this.plotRoot);
        }
        this.basePlotContainer.cacheAsBitmap = false;
        this.inRender = false;
        this.plotRoot.visible = sceneRootState;
    }


    destroy () {
        'use strict';
        // TODO cleanup brush objects

        document.getElementById(this.elementId + '-title').innerHTML = '';
        this.stopAnimation = true;
        if (this.animationId) {
            window.cancelAnimationFrame(this.animationId);
        }
        this.plotPoints = {};
        this.scatter = {};
        // attempt to force context cleanup which is not working in pixijs3
        // test for gl to allow running in non-WebGL environment
        if (this.renderer.gl) {
            try {
                this.renderer.gl.getExtension('WEBGL_lose_context').loseContext();
            } catch(error) {
                console.log('Error forcing WebGL context release: ' + error);
            }
        }
        this.renderer.destroy(); //prevent canvas view removal
        while (this.plotElement.firstChild) {
            this.plotElement.removeChild(this.plotElement.firstChild);
        }

    }

    getParentWidth () {
        let style = window.getComputedStyle(this.plotElement);
        return this.plotElement.offsetWidth - parseFloat(style.paddingLeft) - parseFloat(style.paddingRight) - parseFloat(style.borderLeftWidth) - parseFloat(style.borderRightWidth);
    }

    captureKeys (enable) {

        if (enable) {
            this.keyListener = this.keyInput.bind(this);
            window.addEventListener('keydown', this.keyListener);
        } else {
            window.removeEventListener('keydown', this.keyListener);
        }
    }

    keyInput(key) {
        if ((this.selectOver === PixijsPlotController.SelectionEnum.NONE) || !this.hasFocus) {
            return;
        }
        switch(key.keyCode) {
        case 78: // left arrow
            if (this.numNeighbours > 0 ) {
                ReScatter.controlEventModel.putControlEventModel('numNeighbours', {
                    number: this.numNeighbours - 1,
                    selector: this.dynamicSelectionId
                });
            }
            break;
        case 77: // right arrow
            ReScatter.controlEventModel.putControlEventModel('numNeighbours', {
                number: this.numNeighbours + 1,
                selector: this.dynamicSelectionId
            });
            break;
        default:
            break;
        }
    }

    startDrawing (event) {
        'use strict';
        if (this.renderer.selectOver === PixijsPlotController.SelectionEnum.MOUSEOVER) {
            // no drawing when mouseOverActive is running
            // kludge to prevent click and mouse up confusion
            return;
        }
        $('#' + this.renderer.elementId).css('cursor', 'url(' + ReScatter.cursors('./drawtarget2.png') + ') 20 20, auto');
        this.selectionShapeOrigin = event.data.getLocalPosition(this.renderer.plotRoot);
        this.activeBrushView = new PIXI.Graphics();
        this.activeBrushView.lineStyle(2/this.renderer.zoom, 0xFF0000, 1);
        this.activeBrushModel = undefined;
        //this.brushModels.push(this.activeBrushModel);
        this.brushViewTree.addChild(this.activeBrushView);
        this.freehandPath = [];
        this.mousemove = this.touchmove = this.brushMousemove;
        this.captureMouse = true;
    }

    brushMousemove (event) {
        'use strict';
        if (this.activeBrushView === undefined) {
            return;
        }

        let curPos = event.data.getLocalPosition(this.renderer.plotRoot);
        this.activeBrushView.clear();
        this.activeBrushView.lineStyle(2/this.renderer.zoom, 0xFF0000, 1);

        switch (this.renderer.brushType) {
        case 'Circle': {
            let circCenter = {
                x: this.selectionShapeOrigin.x + (curPos.x - this.selectionShapeOrigin.x) / 2,
                y: this.selectionShapeOrigin.y + (curPos.y - this.selectionShapeOrigin.y) / 2
            };
            let circRadius = Math.sqrt(Math.pow((this.selectionShapeOrigin.x - curPos.x), 2) +
                Math.pow((this.selectionShapeOrigin.y - curPos.y), 2)) / 2;

            this.activeBrushView.drawCircle(circCenter.x, circCenter.y, circRadius);
            this.activeBrushModel = new PIXI.Circle(circCenter.x, circCenter.y, circRadius);

            break;
        }
        case 'Rectangle': {
            // origin mush be top left - lowest x and y
            let xOrigin = (this.selectionShapeOrigin.x < curPos.x) ? this.selectionShapeOrigin.x : curPos.x;
            let yOrigin = (this.selectionShapeOrigin.y < curPos.y) ? this.selectionShapeOrigin.y : curPos.y;

            this.activeBrushView.drawRect(xOrigin, yOrigin,
                Math.abs(curPos.x - this.selectionShapeOrigin.x),
                Math.abs(curPos.y - this.selectionShapeOrigin.y));
            this.activeBrushModel = new PIXI.Rectangle(xOrigin, yOrigin,
                Math.abs(curPos.x - this.selectionShapeOrigin.x),
                Math.abs(curPos.y - this.selectionShapeOrigin.y));
            break;
        }
        case 'Freehand':
            this.freehandPath.push(curPos.clone());
            // close the polygon automatically
            // var closedPath = this.freehandPath.slice(0);
            // closedPath.push(this.freehandPath[0]);
            this.activeBrushView.drawPolygon(this.freehandPath);
            this.activeBrushModel = new PIXI.Polygon(this.freehandPath);

            break;
        default: {
            (()=>{})();
        }
        }

    }

    endDrawing (/*event*/) {
        'use strict';
        this.captureMouse = false;

        $('#' + this.renderer.elementId).css('cursor', 'url(' + ReScatter.cursors('./drawtarget.png') + ') 20 20, auto');
        this.mousemove = this.touchmove = null;

        if (this.activeBrushView === undefined) {
            return;
        }
        if (this.activeBrushModel === undefined) {
            return;
        }
        // Calculate the enclosed points - use the sprite screen positions
        let typeSelection = 'Circle';
        if (this.activeBrushModel.type === PIXI.SHAPES.POLY) {
            // Close the polygon path
            let closedPath = this.freehandPath.slice(0);
            closedPath.push(this.freehandPath[0]);
            this.activeBrushView.drawPolygon(closedPath);
            this.activeBrushModel = new PIXI.Polygon(closedPath);
            typeSelection = 'Freehand ';
        } else if (this.activeBrushModel.type === PIXI.SHAPES.CIRC) {
            typeSelection = 'Circle ';
        } else if (this.activeBrushModel.type === PIXI.SHAPES.RECT) {
            typeSelection = 'Rectangle ';
        }
        let dataPoints = [];

        for (let j = 0, len = this.renderer.allPointSprites.length; j < len; j++) {
            if (this.activeBrushModel.contains(this.renderer.allPointSprites[j].position.x, this.renderer.allPointSprites[j].position.y)) {
                dataPoints.push(j);
            }
        }

        if (dataPoints.length > 0) { //} && this.renderer.selectable) {
            let selOutId = this.renderer.selectionOutId;
            this.activeBrushModel.label = ReScatter.selectionModel.getNewLabel(selOutId);
            ReScatter.selectionModel.putSelection(
                this.activeBrushModel.label,
                this.renderer.elementId,
                dataPoints,
                0x772222,
                'User: ' + typeSelection + ', ' + dataPoints.length + ' points.',
                selOutId,
                this.renderer.plotPropReader.props);
            this.activeBrushView.hitArea = this.activeBrushModel;
            this.activeBrushView.interactive = true;
            this.activeBrushView.visible = false;
            this.activeBrushView.mouseover = function (/*interaction*/) {
                console.log('Shape contains: ' + dataPoints.length + ' points.');
            };
            this.activeBrushView.clear();
            delete this.activeBrushView;
            delete this.activeBrushModel;
        } else {
            this.activeBrushView.clear();
            delete this.activeBrushView;
            delete this.activeBrushModel;
        }

        this.activeBrushView = undefined;
        this.activeBrushModel = undefined;
        this.activeBrushModel = undefined;
    }

    onContextMenu (event) {
        event.preventDefault(); // disable the original context menu
        let kdeVals = this.scatterPoints.kdeValues();
        kdeVals.color = 'Grey';
        if (this.basePlotContainer.filters && this.basePlotContainer.filters.length === 2) {
            kdeVals.color = this.lutFilter.currentName;
        }

        ReScatter.controlEventModel.putControlEventModel('plotContextMenu', {
            plot: this,
            coords: {x: event.clientX, y:event.clientY},
            kde:kdeVals
        });
        this.contextMenuLinked = true;
        event.stopPropagation();
    }

    // function returns a promise - call appropriately
    /**
     * Return a Promise that will perform the selection-> properties mapping for the
     * property in question.
     *
     * @param property - string: property being mapped 'group', 'color', 'size'
     * @param dataPoints - list of int: indexes of points in election
     * @param selectionMap - object: mapping config containing {dataMap:, propMap}
     * @param selectionProp - CSS color: color from plot source
     * @param result - object to hold result
     * @returns {Promise}
     * @private
     */
    __mapProperty (property, dataPoints, selectionMap, selectionProp, result) {


        let mapOp = selectionMap.propMap[property].mapOp;
        let mapFn = selectionMap.propMap[property].mapFn;
        let self = this;
        let updateResult = result;

        //TODO handle failures - reject
        return new Promise(function(resolve/*, reject*/) {
            if (mapOp === undefined) {
                if (mapFn === undefined) {
                    // the default options
                    // Should the group default be all points?
                    // group must be processed first to support the other two defaults
                    let group = updateResult.group;
                    if (property === 'group') {
                        updateResult[property] = dataPoints;
                    } else if (property === 'color') {
                        let colors = new Array(group.length);
                        group.map(function(spriteIndex, arrayIndex) {
                            let sprite = self.allPointSprites[spriteIndex];
                            colors[arrayIndex] = sprite.tint;
                        });
                        updateResult[property] = colors;

                    } else if (property === 'size') {
                        let sizes = new Array(group.length);
                        group.map(function(spriteIndex, arrayIndex) {
                            let sprite = self.allPointSprites[spriteIndex];
                            sizes[arrayIndex] = sprite.pointSize;
                        });
                        updateResult[property] = sizes;
                    }
                } else {
                    updateResult[property] = mapFn(dataPoints, self.plotPropReader.props, selectionProp);
                    //console.log("Done " + property + " for " + self.id);
                }
                resolve(updateResult);
            } else {
                let dataMapper = ReScatter.data.DataMapper.getDataMap(selectionMap.dataMap);
                dataMapper.mapData(dataPoints, mapOp)
                    .then(function (values) {
                        if (mapFn) {
                            updateResult[property] = mapFn(values, self.plotPropReader.props, selectionProp);
                            //console.log("Done " + property + " for " + self.id);
                        } else {
                            updateResult[property] = values;
                        }
                        resolve(updateResult);
                    })
                    .catch(function(e) {
                        console.log('Error in property mapping: ' + e + ' for ' + self.id);
                        resolve(updateResult);
                    });
            }
        });
    }

    processDynamicSelection (context, selectionMap) {
        // Dynamic selections are added to a special container
        // that becomes visible for the lifetime of the selection.
        // The regular selection container is hidden during this
        // time. The add selection logic is more or less identical
        // to that of a normal selection.

        switch (context.op) {
        case 'create':
            this.addSelectionToContainer(this.dynamicRoot,
                undefined,
                context,
                selectionMap);
            break;

        case 'transitive':
            this.applyTransitiveSelection(context,
                selectionMap);
            break;
        case 'delete':
            try {
                this.dynamicRoot.removeChildren();
                this.dynamicRoot.visible = false;
                this.selectionsRoot.visible = true;
                this.render();
            }
            catch(e) {
                console.log('Error processing dynamic selection ' + e);
            }
            finally {
                let self = this;
                setTimeout(function () {
                    self.processingDone();
                }, 0);
            }
            break;
        default:
            this.processingDone();
        }
    }

    addSelectionToContainer (container, selectionViews, context, selectionMap) {
        //console.log("Adding group " + context.sel.label + " in: " + this.id);
        // Start a potentially asynchronous chain with a resolved promise (future)
        // that will collect the properties fro the points
        let sequence = Promise.resolve({color: undefined, size: undefined, group: undefined});
        let self = this;
        sequence
            .then(function(pointProps){
            //console.log("Group for group " + context.sel.label + " in: " + self.id);
                return self.__mapProperty('group',
                    context.sel.dataPoints,
                    selectionMap,
                    undefined,
                    pointProps);})
            .then(function(pointProps){
            //console.log("Color for group " + context.sel.label + " in: " + self.id);
                return self.__mapProperty('color',
                    context.sel.dataPoints,
                    selectionMap,
                    context.sel.color,
                    pointProps);})
            .then(function(pointProps){
            //console.log("Size for group " + context.sel.label + " in: " + self.id);
                return self.__mapProperty('size',
                    context.sel.dataPoints,
                    selectionMap,
                    undefined,
                    pointProps);})
            .then(function(pointProps) {
                try {
                    let selectionProps = selectionMap.propMap;
                    let colorByGroup = selectionProps.color.propAssign !== DataMapper.propAssign.POINT;
                    let sizeByGroup = selectionProps.size.propAssign !== DataMapper.propAssign.POINT;

                    let groupColor = colorByGroup ? pointProps.color : undefined;
                    let groupSize = sizeByGroup ? pointProps.size : 4;
                    if (context.type === 'dyna') {
                        self.dynamicRoot.removeChildren();
                    }
                    let selectionView = new ReScatter.view.PointGroupView(
                        self,
                        context.sel.label,
                        container,
                        groupSize, groupColor,
                        self.xScaleFunc, self.yScaleFunc,
                        self.zoom
                    );
                    let pointShape;
                    if (selectionProps.effects) {
                        selectionProps.effects.map(function (effect) {
                            switch (effect) {
                            case 'Outline':
                                selectionView.outline = true;
                                break;
                            case 'X':
                            case 'O':
                                pointShape = effect;
                                break;
                            }
                        });
                    }

                    //let dataPoints = pointProps.group;
                    // TODO allow user supplied mouseover - this is a default
                    let mouseoverFn = function (interaction) {
                        self.annotateInteractionTarget(interaction);
                    };

                    for (let i = 0, len = pointProps.group.length; i < len; i++) {
                        let pointColor = colorByGroup ? undefined : pointProps.color[i];
                        let pointSize = sizeByGroup ? undefined : pointProps.size[i];
                        let pointIndex = pointProps.group[i];
                        // mouseover currently undefined
                        let sprite = selectionView.addPoint(self.allPointSprites[pointIndex].point,
                            pointColor, pointSize, pointShape,
                            self.allPointSprites[pointIndex]);
                        sprite.mouseover = mouseoverFn;
                    }
                    if (selectionViews) {
                        self.selectionViews[context.sel.label] = selectionView;
                    }
                    if (context.type === 'dyna') {
                        self.dynamicRoot.visible = true;
                        self.selectionsRoot.visible = false;
                        selectionView.visible = true;

                    } else {
                        if (context.sel.background) {
                            selectionView.visible = false;
                        }
                    //console.log("Added " + context.sel.label + " in " + self.id);
                    }
                }
                catch(e) {
                    console.log('Error adding selection ' + e + ' for ' + self.id);
                }
                finally {
                    setTimeout(function () {
                        self.processingDone();
                    }, 0);
                    self.render();
                }
            })
            .catch(function(e) {
                console.log('Error adding selection:' + e + ' in plot: ' + self.id);
                setTimeout(function(){self.processingDone();}, 0);
            });
    }

    applyTransitiveSelection (context, selectionMap) {
        let self = this;
        try {
            let mapFn = selectionMap.propFilter.mapFn;
            let selectedPoints = [];
            context.sel.dataPoints.forEach(function (elem) {
                let filterVal = mapFn(elem, self.plotPropReader.props);
                if (filterVal !== -1) {
                    selectedPoints.push(filterVal);
                }
            });
            // Convert the transitive to a permanent selection
            if (selectedPoints.length > 0) {
                let label = ReScatter.selectionModel.getNewLabel(this.selectionOutId);
                ReScatter.selectionModel.putSelection(
                    label,
                    this.elementId,
                    selectedPoints,
                    0x772222,
                    this.selectionOutId + ' selection via: ' + context.sel.originator + ', points: ' + selectedPoints.length,
                    this.selectionOutId,
                    this.plotPropReader.props);
            }

        } catch(e) {
            console.log('Error performing transitive selection:' + e + ' in plot: ' + self.id);
        } finally {
            setTimeout(function(){self.processingDone();}, 0);
        }
    }

    __deletePointGroup (label) {
        let removeView = this.selectionViews[label];
        if (removeView !== undefined) {
            //console.log("Remove " + label + " in: " + this.id);
            delete(this.selectionViews[label]);
            removeView.destroy();
            this.render();
        }
    }


    displayPlotData (colors) {
        'use strict';

        console.log('display plot data for: ' + this.annotations.length);
        let self = this;

        let dataMaxX = Math.max.apply(Math, this.plotPoints.map(function (d) {
            return d.x;
        }));
        let dataMinX = Math.min.apply(Math, this.plotPoints.map(function (d) {
            return d.x;
        }));
        let dataRangeX = dataMaxX - dataMinX;
        let dataMaxY = Math.max.apply(Math, this.plotPoints.map(function (d) {
            return d.y;
        }));
        let dataMinY = Math.min.apply(Math, this.plotPoints.map(function (d) {
            return d.y;
        }));
        let dataRangeY = dataMaxY - dataMinY;
        //let plotSize = this.plotSize;

        // shifting and scaling (the points are plotted around 0,0)
        //     this.scaleY = this.plotSize / this.dataRangeY;
        this.yScaleFunc = function (y) {
            return ((y - dataMinY) * ((self.plotSize - 40) / dataRangeY)) + 20;
        };
        this.xScaleFunc = function (x) {
            return ((x - dataMinX) * ((self.plotSize - 40) / dataRangeX)) + 20;
        };

        function dispatchLoadedEvent(self) {
            ReScatter.controlEventModel.putControlEventModel('rendererLoadComplete', {
                renderer:self,
                rendererId:self.elementId,
                type:'plot'
            });
        }
        function makeDataPointGroups() {
            let mouseoverFn = function (interaction) {
                self.annotateInteractionTarget(interaction);
            };
            //let mousedownFn = function (interaction) {
            //    self.pointClicked(interaction);
            //};
            // Plot points are placed in a single PointGroupView instance located at the
            // basePlotContainer (deepest z-order)
            let containerCount = 0;
            console.log('using single container, annotations: ' + self.annotations.length);
            self.scatterPoints = new ReScatter.view.PointGroupView(
                self,
                'pointGroup_' + containerCount,
                self.basePlotContainer,
                3, undefined,
                self.xScaleFunc, self.yScaleFunc,
                self.zoom);

            let makeSprites = function (index) {
                console.log('Sprites in container for: ' + self.elementId);
                for (let j = index; j < self.plotPoints.length; j++) {
                    let pointS = self.plotPoints[j];
                    self.allPointSprites[j] = self.scatterPoints.addPoint(pointS, colors[j]);
                    self.allPointSprites[j].mouseover = mouseoverFn;
                }
                //self.scatterPoints.setActive();
                self.scatterPoints.visible = true;
                self.render();
                console.log('Start rendering');
                self.frameDelay = 50;
                self.processingLoop(true);
                setTimeout(function(){dispatchLoadedEvent(self);}, 100);
            };
            makeSprites(0);


        }
        makeDataPointGroups();
        //self.freezePending = true;
    }


    annotateInteractionTarget (interactionData) {
        'use strict';
        // Draw a popup text containing annotation data connected to the mouse position
        // by a red line.
        let target = interactionData.target;
        if (!target.point) {return;}
        this.annotatePoint(target, interactionData);
    }

    annotatePoint (target, interactionData) {
        'use strict';
        // Draw a popup text containing annotation data connected to the mouse position
        // by a red line.
        // During drawing disable annotation
        if (this.plotRoot.captureMouse) {
            return;
        }
        if (interactionData !== undefined) {
            interactionData.stopPropagation(); // prevent cursor jumping
        }
        this.popupContainer.removeChildren();
        this.annotationTarget = target;
        let annotText = target.point.sym;
        //console.log(annotText);
        let fontSize = Math.round(14/this.zoom);
        let outlineThickness = Math.round(5/this.zoom);
        let resolution = PIXI.RESOLUTION * this.zoom;
        this.textPopup = new PIXI.Text(annotText, {
            font: 'bold ' + fontSize + 'px Arial',
            fill: 'white',
            stroke: 'black',
            strokeThickness: outlineThickness
        }, resolution);
        // Position the animation towards the center of the plot to prevent edge problems.
        // Assuming plot is centered on 0,0 annotation is always on the origin side
        let rad = Math.sqrt(Math.pow(target.point.x,2) + Math.pow(target.point.y,2)); //dist to center in coordSpace
        let lineLength = 20/this.zoom;
        let lineThickness = 2/this.zoom;
        let dispX = -lineLength * target.point.x / rad; // scale the line based on the relation
        let dispY = -lineLength * target.point.y / rad;
        this.textPopup.x = target.position.x + dispX;
        this.textPopup.y = target.position.y + dispY;
        // The text anchor is at one of the corners depending on which quarter the point is in.
        this.textPopup.anchor.x = ((target.point.x < 0) ? 0:1);
        this.textPopup.anchor.y = ((target.point.y < 0) ? 0:1);
        this.annotLine = new PIXI.Graphics();
        this.annotLine.lineStyle(lineThickness, 0xFF0000, 1);
        this.annotLine.moveTo(target.position.x, target.position.y);
        this.annotLine.lineTo(this.textPopup.x, this.textPopup.y);


        this.popup = this.popupContainer.addChild(this.textPopup);
        this.popup = this.popupContainer.addChild(this.annotLine);

        if (this.dynamicSelectionId &&
            (this.selectOver === PixijsPlotController.SelectionEnum.MOUSEOVER)) {
            // when annotating a selection the sprite will not be in allPointSprites
            this.mouseOverDynamicSelection(target.point.index);
        }

    }

    mouseOverDynamicSelection (pointIndex) {
        // when annotating a selection the sprite will not be in allPointSprites
        this.mouseOverSeedIndex = pointIndex;
        this.mouseOverIndexes = [];

        if (this.numNeighbours >= 0) {
            // the kdtree returns the seed point as part of the list
            let nearPoints = this.tree.nearest(this.plotPoints[pointIndex], this.numNeighbours + 1);
            for (let i = 0; i < nearPoints.length; i++) {
                if (!this.mouseOverExcludeSeed || (this.mouseOverExcludeSeed && (pointIndex !== nearPoints[i][0].i))) {
                    this.mouseOverIndexes.push(nearPoints[i][0].i);
                }
            }
        }
        if (pointIndex > -1 && (this.mouseOverIndexes.length > 0)) {
            ReScatter.dynamicSelectionModel.putDynamicSelection(
                this.elementId,
                this.mouseOverIndexes, //[pointIndex],
                0x772222,
                this.dynamicSelectionId,
                this.plotPropReader.props);
        }
    }

    applyZoomToPoint (event) {
        // This zooms around the event point
        let plotOffset = this.plotRoot.position;
        //x0 - x offset for zoom point
        //y0 - x offset for zoom point
        //z0 - previous zoom
        //z1 - new zoom
        //p1 - new x offset for scaled plot
        //q1 - new y offset for scaled plot
        let z1 = this.zoom;
        let p1 = 0;
        let q1 = 0;
        if (this.zoomFactor !== 1) {
            let z0 = this.plotRoot.scale.x;
            let x0 = event.offsetX;
            let y0 = event.offsetY;
            let p0 = plotOffset.x;
            let q0 = plotOffset.y;
            // from [translate back to zoom point]x[zoom scale]x[translate zoom point to origin]
            p1 = ((z1 / z0) * (p0 - x0)) + x0;
            q1 = ((z1 / z0) * (q0 - y0)) + y0;
        }
        this.plotRoot.position = new PIXI.Point(p1, q1);
        this.plotRoot.scale = new PIXI.Point(this.zoom, this.zoom);
        // rescale the points on the scatter plot...

        this.zoomActiveOverlays(this);

        //this.zoomed = true;
        this.render();
    }

    zoomActiveOverlays (self) {
        self.scatterPoints.zoom(self.zoom);
        Object.keys(self.selectionViews).forEach(function(val) {
            if (self.selectionViews[val].visible) {
                self.selectionViews[val].zoom(self.zoom);
            }
        });
        // ... and the popup annotation if any
        if (self.popupContainer.children.length > 0) {
            self.annotatePoint(self.annotationTarget);
        }
    }

    zoomWheel (event) {
        if (event.ctrlKey || event.metaKey) {
            event.preventDefault();

            if (event.deltaY < 0 && this.currentZoomLevel < this.maxZoomLevel) {
                this.currentZoomLevel++;
                this.zoomFactor = this.zoomLevels[this.currentZoomLevel];
                this.applyZoomToPoint(event);
            } else if (event.deltaY > 0 && this.currentZoomLevel > 0) {
                this.currentZoomLevel--;
                this.zoomFactor = this.zoomLevels[this.currentZoomLevel];
                this.applyZoomToPoint(event);
            }
        }
    }

    selectOnClick (/*event*/) {

        if (this.selectOver !== PixijsPlotController.SelectionEnum.MOUSEOVER) {
            return;
        }
        if (this.mouseOverIndexes.length === 0) {
            return;
        }
        let label = ReScatter.selectionModel.getNewLabel(this.selectionOutId);
        ReScatter.selectionModel.putSelection(
            label,
            this.renderer.elementId,
            this.mouseOverIndexes,
            0x772222,
            'Seed: ' + this.plotPropReader.getSymbol(this.mouseOverSeedIndex) + (this.mouseOverExcludeSeed ? ' (excluded) ': ' ') + this.mouseOverIndexes.length + ' points.',
            this.selectionOutId);
    }

    getPropertyIndexNeighbours (indexes) {
        let seedAndNeighborIndexes = [];
        let self = this;
        indexes.forEach(function(pointIndex) {
            if (self.numNeighbours >= 0) {
                // the kdtree returns the seed point as part of the list
                let nearPoints = self.tree.nearest(self.plotPoints[pointIndex], self.numNeighbours + 1);
                for (let i = 0; i < nearPoints.length; i++) {
                    if (!self.mouseOverExcludeSeed || (self.mouseOverExcludeSeed && (pointIndex !== nearPoints[i][0].i))) {
                        seedAndNeighborIndexes.push(nearPoints[i][0].i);
                    }
                }
            }
        });
        return seedAndNeighborIndexes;
    }

    neighbourhoodSelectIndexes (indexes) {
        this.mouseOverIndexes = [];
        this.propertyOverIndexes = indexes;
        let seedAndNeighborIndexes = this.getPropertyIndexNeighbours(indexes);
        if (seedAndNeighborIndexes.length > 0) {
            ReScatter.dynamicSelectionModel.putDynamicSelection(
                this.elementId,
                seedAndNeighborIndexes, //[pointIndex],
                0x772222,
                this.dynamicSelectionId,
                this.plotPropReader.props);
        }
    }

    selectOnProperty () {
        if (this.propertyOverIndexes.length === 0) {
            return;
        }
        let seedAndNeighborIndexes = this.getPropertyIndexNeighbours(this.propertyOverIndexes);
        let label = ReScatter.selectionModel.getNewLabel(this.selectionOutId);
        ReScatter.selectionModel.putSelection(
            label,
            this.elementId,
            seedAndNeighborIndexes,
            0x772222,
            'Seed: ' + this.plotPropReader.getSymbol(this.propertyOverIndexes[0]) + (this.mouseOverExcludeSeed ? ' (excluded) ': ' ') + seedAndNeighborIndexes.length + ' points.',
            this.selectionOutId);
    }

    get zoom() {
        return this.resizeZoom * this.zoomFactor;
    }

    static get SelectionEnum() { return {
        NONE: 0,
        MOUSEOVER: 1,
        PROPOVER: 2
    };}
}


//</Class definition for the PixijsPlotController>
// Implement the supported protocols

PlotProtocol.impl(PixijsPlotController, [], {
    loadPlotData (points, props, plotProps) {
        // points: array of x,y tuples - one tuple per point
        //
        // props: object containing voxel_props. voxel_props has the following
        //  format : {voxel_props:{prop1_name: [array of props], prop2_name: [array of props] ...}}
        //  the length of the arrays should match the number of points
        //
        // plotProps: is an object which is use to determine how the point appears when it is
        // plotted. It is use to convert values in props to display format.
        // plotProps contains all or some of the following fields
        // { color : - the color for the point
        //   id : - unique id for the point (use to link to other data)
        //   symbol : - test associated with the point
        //   size : - size of the point shape
        //   shape : - TO BE IMPLEMENTED currently only circle is supported will add various polygons
        //   group : - value to group by - if none the points will not be grouped
        //   primary: - primary property for user selection (a human readable, preferably unique property)
        // }
        // There are four ways to supply a plotProp in combination with props:
        //      Direct, Mapped, Function and Literal
        // Direct: If the property is undefined (or has an undefined value) then the value is retrieved
        //      from props e.g. color = props[i].color, in addition if it is not defined in props
        //      then a default is provided
        // Mapped: If the object property value is an object the the following is performed
        //      color = props[i][plotProps.color]
        // Function: if the value is a function then that function is used on the
        //      e.g. plotProps.color(props[i]) to get the value
        // Literal: If the object property value is defined and is anything other than a
        //      function or an object then the value is used as is
        //      color = plotProps.color

        'use strict';
        this.plotPoints = new Array(points.length);
        this.allPointSprites = new Array(points.length);
        let tempPoints = new Array(points.length); // gets sorts by the kdtree
        this.annotationPoints = {};
        this.plotPropReader = new PlotPropReader(props, plotProps);
        let distMetric = function(a, b){
            if (a === undefined || b === undefined) {
                return 1000;
            }
            return Math.pow(a.x- b.x, 2) + Math.pow(a.y - b.y, 2);
        };
        // console.log('load plot data for: ' + this.annotations.length);

        this.renderer.backgroundColor = this.plotPropReader.getBackgroundColor();
        let colors = [];
        let self = this;
        function loadPoints(index) {
            let i;
            for (i = index; i < points.length; i++) {
                let point = {
                    x: points[i][0],
                    y: -points[i][1], //y coord inverted
                    id: self.plotPropReader.getId(i),
                    sym: self.plotPropReader.getSymbol(i),
                    properties: self.plotPropReader.props,
                    index: i
                };
                tempPoints[i] = {x:points[i][0], y:-points[i][1], i:i};
                colors.push(self.plotPropReader.getColor(i));
                self.plotPoints[i] = point;
                let group = self.plotPropReader.getGroup(i);
                if (group) {
                    if (self.annotations.indexOf(group) === -1) {
                        self.annotations.push(group);
                        self.annotationsColor.push(colors[i]);
                        self.annotationPoints[group] = [];
                    }
                    self.annotationPoints[group].push(point);
                }
                if (i % 1000 === 999) {
                    break;
                }
            }

            if (i < points.length - 1 ) {
                ReScatter.controlEventModel.putControlEventModel('loadingProgress', {
                    id: self.id,
                    total: points.length,
                    loaded: i+1
                });
                setTimeout(loadPoints, 10, i + 1);
            } else {
                self.tree = new kdTree.kdTree(tempPoints, distMetric, ['x', 'y', 'i']); // jshint ignore:line
                setTimeout(self.displayPlotData.bind(self, colors), 10);
            }

        }
        //console.log('load points for: ' + self.annotations.length);
        loadPoints(0);
    },

    // resize the canvas
    onResize () {
        this.plotWindowSize = this.plotElement.clientWidth;
        let oldZoom = this.zoom;
        this.resizeZoom = this.plotWindowSize/this.originalSize;
        let zoomChange = this.zoom/oldZoom;
        let plotOffset = this.plotRoot.position;
        plotOffset.x = zoomChange * plotOffset.x;
        plotOffset.y = zoomChange * plotOffset.y;
        this.plotRoot.position = plotOffset;
        this.plotRoot.scale = new PIXI.Point(this.zoom, this.zoom);
        this.renderer.resize(this.plotWindowSize, this.plotWindowSize);
        this.zoomActiveOverlays(this);
        this.render();
    }

});


SelectionProtocol.impl(PixijsPlotController, [], {
    processSelectionEvent (context) {
        let selectionMap;
        if (context.type === 'dyna') {
            selectionMap = this.dynamicSelectionIn[context.id];
            if (selectionMap !== undefined) {
                this.processDynamicSelection(context, selectionMap);
            } else {
                this.processingDone();
            }
            return;
        }

        selectionMap = this.selectionIn[context.id];
        if (context.op === 'create') {
            this.addSelectionToContainer(this.selectionsRoot,
                this.selectionViews,
                context, selectionMap);
            return;
        }
        try {
            switch (context.op) {
            case 'delete':
                this.__deletePointGroup(context.sel.label);
                break;
            case 'color': {
                let colorAll = selectionMap.propMap.color.propAssign !== DataMapper.propAssign.POINT;
                if (colorAll) {
                    let recolorView = this.selectionViews[context.sel.label];
                    //console.log("Recolor " + context.sel.label + " in: " + this.id);
                    recolorView.setColor(context.sel.color);
                    if (recolorView.visible) {
                        this.render();
                    }
                }
                break;
            }
            case 'hide': {
                let hiddenView = this.selectionViews[context.sel.label];
                //console.log("Inactivate " + context.sel.label + " in: " + this.id);
                if (hiddenView) {
                    hiddenView.visible = false;
                    this.render();
                }
                break;
            }
            case 'show': {
                let visibleView = this.selectionViews[context.sel.label];
                //console.log("Activate " + context.sel.label + " in: " + this.id);
                if (visibleView) {
                    this.dynamicRoot.visible = false;
                    this.selectionsRoot.visible = true;
                    visibleView.visible = true;
                    visibleView.zoom(this.zoom);
                    this.render();
                }
                break;
            }
            case 'update': {
                if (this.selectionOutId === context.sel.selectionId) {
                    // Unoptimized implementation: delete the old, add new
                    this.__deletePointGroup(context.sel.label);
                    // clone the command and change it to a create.
                    let newcontext = $.extend({}, context);
                    newcontext.op = 'create';
                    this.addSelectionToContainer(this.selectionsRoot,
                        this.selectionViews,
                        newcontext, selectionMap);
                }
                break;
            }
            default:
                console.log('Unmatched context operation ' + context);
            }
        }
        catch(e) {
            console.log('Error processing context op ' + e);
        }
        finally {
            this.processingDone();
        }
    }

});

ControlProtocol.impl(PixijsPlotController, [], {
    onControlEvent (eventContext) {
        switch (eventContext.eventName) {
        case 'brushMode':
            this.brushType = eventContext.event.brushType;
            break;
        case 'editOp':
            this.editOp = eventContext.event.editOp;
            break;
        case 'editMode':
            this.editMode = 'NEW';
            if (eventContext.event.editMode === 'EXISTING') {
                if (this.selectionOutId === eventContext.event.selectionId) {
                    let activeView = this.selectionViews[eventContext.event.editTarget];
                    if (activeView) {
                        activeView.visible = true;
                        this.editMode = 'EXISTING';
                    }
                }
            }
            break;
        case 'numNeighbours':
            if (eventContext.event.selector === this.dynamicSelectionId) {
                this.numNeighbours = eventContext.event.number;
                // refresh the neighbourhood blob
                if (this.selectOver !== PixijsPlotController.SelectionEnum.NONE && this.contextMenuLinked) {
                    switch (this.selectOver) {
                    case PixijsPlotController.SelectionEnum.MOUSEOVER:
                        this.mouseOverDynamicSelection(this.mouseOverSeedIndex);
                        break;
                    case PixijsPlotController.SelectionEnum.PROPOVER:
                        this.neighbourhoodSelectIndexes(this.propertyOverIndexes);
                        break;
                    default:
                        break;
                    }
                }
            }
            break;
        case 'plotContextMenuClosed':
            if (eventContext.event.selector === this.dynamicSelectionId) {
                if (this.id === eventContext.event.value.formId) {
                    this.contextMenuLinked = false;
                }
            }
            break;
        case 'mouseOverActive':
            if (eventContext.event.selector === this.dynamicSelectionId) {
                this.selectOver = eventContext.event.active;
                this.mouseOverExcludeSeed = eventContext.event.noSeed;
                this.captureKeys(this.selectOver !== PixijsPlotController.SelectionEnum.NONE);
            }
            break;
        case 'kdePlotActive':
            if (eventContext.event.selector === this.dynamicSelectionId) {
                let kpaVal = eventContext.event.value;
                if (kpaVal.active) {
                    this.scatterPoints.setKdeOn(kpaVal.sigma, kpaVal.contours);
                    if (!this.colorSet) {
                        this.lutFilter = new ReScatter.view.LUTFilter(this.plotPropReader.getBackgroundColor());
                        this.colorSet = [this.lutFilter];
                    }
                    this.basePlotContainer.filters = this.colorSet;
                    let color = kpaVal.color === 'Grey'? 'gray' : kpaVal.color;
                    let self = this;
                    this.lutFilter.setLut(color, function() {
                        self.basePlotContainer.filters = self.colorSet;
                        self.render();
                    });
                } else {
                    this.scatterPoints.setKdeOff();
                    this.basePlotContainer.filters = undefined;
                    this.render();
                }
            }
            break;
        case 'kdePlotChanged':
            if (eventContext.event.selector === this.dynamicSelectionId) {
                let kpcVal = eventContext.event.value;
                if (kpcVal.active) {
                    this.scatterPoints.updateKde(kpcVal.sigma, kpcVal.contours);
                    //this.stepFilter.step = kpcVal.contours;
                    let color = kpcVal.color === 'Grey'? 'gray' : kpcVal.color;
                    let self = this;
                    this.lutFilter.setLut(color, function() {
                        self.basePlotContainer.filters = self.colorSet;
                        self.render();
                    });
                }
            }
            break;
        case 'propertySelect':
            if (eventContext.event.selector === this.dynamicSelectionId &&
                    eventContext.event.targetPlotId === this.id) {
                this.neighbourhoodSelectIndexes(eventContext.event.indexes);
            }
            break;
        case 'savePropertySelect':
            if (eventContext.event.selector === this.dynamicSelectionId &&
                    eventContext.event.targetPlotId === this.id) {
                this.selectOnProperty();
            }
            break;
        case 'changePointMode':
            this.currentConfig = eventContext.event.pointMode;
            this.selectionIn = this.switchableSelections.getSelectionMapping(this.currentConfig);
            this.dynamicSelectionIn = this.switchableSelections.getDynamicSelectionMapping(this.currentConfig);
            break;
        default:
            return;
        }
    }
});

// Implement a snapshot protocol to allow screen capture
SnapshotProtocolForCanvas.impl(PixijsPlotController, [], {
    getNumberofCanvases() {
        return 1; // We have a single canvas
    },

    getCanvasNameAtIndex(/*index*/) {
        return this.id;
    },

    getCanvasAtIndex(/*index*/) {
        return this.renderer.view; // Return the canvas used by the WebGL renderer
    }
});
